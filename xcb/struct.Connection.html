<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`Connection` is the central object of XCB."><title>Connection in xcb - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="xcb" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../xcb/index.html">xcb</a><span class="version">1.5.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Connection</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.active_extensions" title="active_extensions">active_extensions</a></li><li><a href="#method.active_extensions_data" title="active_extensions_data">active_extensions_data</a></li><li><a href="#method.check_request" title="check_request">check_request</a></li><li><a href="#method.connect" title="connect">connect</a></li><li><a href="#method.connect_to_display_with_auth_info" title="connect_to_display_with_auth_info">connect_to_display_with_auth_info</a></li><li><a href="#method.connect_to_display_with_auth_info_and_extensions" title="connect_to_display_with_auth_info_and_extensions">connect_to_display_with_auth_info_and_extensions</a></li><li><a href="#method.connect_to_fd" title="connect_to_fd">connect_to_fd</a></li><li><a href="#method.connect_to_fd_with_extensions" title="connect_to_fd_with_extensions">connect_to_fd_with_extensions</a></li><li><a href="#method.connect_with_extensions" title="connect_with_extensions">connect_with_extensions</a></li><li><a href="#method.connect_with_xlib_display" title="connect_with_xlib_display">connect_with_xlib_display</a></li><li><a href="#method.connect_with_xlib_display_and_extensions" title="connect_with_xlib_display_and_extensions">connect_with_xlib_display_and_extensions</a></li><li><a href="#method.flush" title="flush">flush</a></li><li><a href="#method.from_raw_conn" title="from_raw_conn">from_raw_conn</a></li><li><a href="#method.from_raw_conn_and_extensions" title="from_raw_conn_and_extensions">from_raw_conn_and_extensions</a></li><li><a href="#method.from_xlib_display" title="from_xlib_display">from_xlib_display</a></li><li><a href="#method.from_xlib_display_and_extensions" title="from_xlib_display_and_extensions">from_xlib_display_and_extensions</a></li><li><a href="#method.generate_id" title="generate_id">generate_id</a></li><li><a href="#method.get_maximum_request_length" title="get_maximum_request_length">get_maximum_request_length</a></li><li><a href="#method.get_raw_conn" title="get_raw_conn">get_raw_conn</a></li><li><a href="#method.get_raw_dpy" title="get_raw_dpy">get_raw_dpy</a></li><li><a href="#method.get_setup" title="get_setup">get_setup</a></li><li><a href="#method.has_error" title="has_error">has_error</a></li><li><a href="#method.into_raw_conn" title="into_raw_conn">into_raw_conn</a></li><li><a href="#method.poll_for_event" title="poll_for_event">poll_for_event</a></li><li><a href="#method.poll_for_queued_event" title="poll_for_queued_event">poll_for_queued_event</a></li><li><a href="#method.poll_for_reply" title="poll_for_reply">poll_for_reply</a></li><li><a href="#method.poll_for_reply_unchecked" title="poll_for_reply_unchecked">poll_for_reply_unchecked</a></li><li><a href="#method.poll_for_special_event" title="poll_for_special_event">poll_for_special_event</a></li><li><a href="#method.poll_for_special_event2" title="poll_for_special_event2">poll_for_special_event2</a></li><li><a href="#method.prefetch_maximum_request_length" title="prefetch_maximum_request_length">prefetch_maximum_request_length</a></li><li><a href="#method.register_for_special_event" title="register_for_special_event">register_for_special_event</a></li><li><a href="#method.register_for_special_xge" title="register_for_special_xge">register_for_special_xge</a></li><li><a href="#method.resolve_error" title="resolve_error">resolve_error</a></li><li><a href="#method.resolve_event" title="resolve_event">resolve_event</a></li><li><a href="#method.send_and_check_request" title="send_and_check_request">send_and_check_request</a></li><li><a href="#method.send_request" title="send_request">send_request</a></li><li><a href="#method.send_request_checked" title="send_request_checked">send_request_checked</a></li><li><a href="#method.send_request_unchecked" title="send_request_unchecked">send_request_unchecked</a></li><li><a href="#method.set_event_queue_owner" title="set_event_queue_owner">set_event_queue_owner</a></li><li><a href="#method.total_read" title="total_read">total_read</a></li><li><a href="#method.total_written" title="total_written">total_written</a></li><li><a href="#method.unregister_for_special_event" title="unregister_for_special_event">unregister_for_special_event</a></li><li><a href="#method.unregister_for_special_xge" title="unregister_for_special_xge">unregister_for_special_xge</a></li><li><a href="#method.wait_for_event" title="wait_for_event">wait_for_event</a></li><li><a href="#method.wait_for_reply" title="wait_for_reply">wait_for_reply</a></li><li><a href="#method.wait_for_reply_unchecked" title="wait_for_reply_unchecked">wait_for_reply_unchecked</a></li><li><a href="#method.wait_for_special_event" title="wait_for_special_event">wait_for_special_event</a></li><li><a href="#method.wait_for_special_event2" title="wait_for_special_event2">wait_for_special_event2</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsRawFd-for-Connection" title="AsRawFd">AsRawFd</a></li><li><a href="#impl-AsRawXcbConnection-for-Connection" title="AsRawXcbConnection">AsRawXcbConnection</a></li><li><a href="#impl-AsRef%3CConnection%3E-for-Connection" title="AsRef&#60;Connection&#62;">AsRef&#60;Connection&#62;</a></li><li><a href="#impl-Drop-for-Connection" title="Drop">Drop</a></li><li><a href="#impl-Send-for-Connection" title="Send">Send</a></li><li><a href="#impl-Sync-for-Connection" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Connection" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Connection" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-Connection" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Connection" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate xcb</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">xcb</a></span><h1>Struct <span class="struct">Connection</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/xcb/base.rs.html#683-698">source</a> </span></div><pre class="rust item-decl"><code>pub struct Connection { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>Connection</code> is the central object of XCB.</p>
<p>It handles all communications with the X server.
It dispatches the requests, receives the replies, poll/wait the events.
It also resolves the errors and events from X server.</p>
<p><code>Connection</code> is thread safe.</p>
<p>It internally wraps an <code>xcb_connection_t</code> object and
will call <code>xcb_disconnect</code> when the <code>Connection</code> goes out of scope.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#703-1898">source</a><a href="#impl-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.connect" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#719-721">source</a><h4 class="code-header">pub fn <a href="#method.connect" class="fn">connect</a>(display_name: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.str.html">str</a>&gt;) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server.</p>
<p>Connects to the X server specified by <code>display_name.</code> If
<code>display_name</code> is <code>None,</code> uses the value of the <code>DISPLAY</code> environment
variable.</p>
<p>If no screen is preferred, the second member of the tuple is set to 0.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() -&gt; xcb::Result&lt;()&gt; {
    <span class="kw">let </span>(conn, screen) = xcb::Connection::connect(<span class="prelude-val">None</span>)<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_with_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#746-765">source</a><h4 class="code-header">pub fn <a href="#method.connect_with_extensions" class="fn">connect_with_extensions</a>(
    display_name: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.str.html">str</a>&gt;,
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server and cache extension data.</p>
<p>Connects to the X server specified by <code>display_name.</code> If
<code>display_name</code> is <code>None,</code> uses the value of the <code>DISPLAY</code> environment
variable.</p>
<p>Extension data specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<p>If no screen is preferred, the second member of the tuple is set to 0.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if one of the mandatory extension is not present.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() -&gt; xcb::Result&lt;()&gt; {
    <span class="kw">let </span>(conn, screen) = xcb::Connection::connect_with_extensions(
        <span class="prelude-val">None</span>, <span class="kw-2">&amp;</span>[xcb::Extension::Input, xcb::Extension::Xkb], <span class="kw-2">&amp;</span>[]
    )<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_with_xlib_display" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#775-789">source</a><h4 class="code-header">pub fn <a href="#method.connect_with_xlib_display" class="fn">connect_with_xlib_display</a>() -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Open a new connection with Xlib.</p>
<p>The event queue owner defaults to Xlib.
One would need to open an XCB connection with Xlib in order to use
OpenGL.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_with_xlib_display_and_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#805-822">source</a><h4 class="code-header">pub fn <a href="#method.connect_with_xlib_display_and_extensions" class="fn">connect_with_xlib_display_and_extensions</a>(
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Open a new connection with Xlib and cache the provided extensions data.</p>
<p>Data of extensions specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<p>The event queue owner defaults to Xlib.
One would need to open an XCB connection with Xlib in order to use
OpenGL.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h5>
<p>Panics if one of the mandatory extension is not present.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_to_fd" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#829-831">source</a><h4 class="code-header">pub fn <a href="#method.connect_to_fd" class="fn">connect_to_fd</a>(
    fd: <a class="type" href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/type.RawFd.html" title="type std::os::fd::raw::RawFd">RawFd</a>,
    auth_info: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.AuthInfo.html" title="struct xcb::AuthInfo">AuthInfo</a>&lt;'_&gt;&gt;,
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server with an open socket file descriptor and optional authentification info.</p>
<p>Connects to an X server, given the open socket fd and the
<code>auth_info</code>. The file descriptor <code>fd</code> is bidirectionally connected to an X server.
If the connection should be unauthenticated, <code>auth_info</code> must be <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_to_fd_with_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#844-878">source</a><h4 class="code-header">pub fn <a href="#method.connect_to_fd_with_extensions" class="fn">connect_to_fd_with_extensions</a>(
    fd: <a class="type" href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/type.RawFd.html" title="type std::os::fd::raw::RawFd">RawFd</a>,
    auth_info: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.AuthInfo.html" title="struct xcb::AuthInfo">AuthInfo</a>&lt;'_&gt;&gt;,
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server with an open socket file descriptor and optional authentification info.</p>
<p>Extension data specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<p>Connects to an X server, given the open socket fd and the
<code>auth_info</code>. The file descriptor <code>fd</code> is bidirectionally connected to an X server.
If the connection should be unauthenticated, <code>auth_info</code> must be <code>None</code>.</p>
<h5 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h5>
<p>Panics if one of the mandatory extension is not present.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_to_display_with_auth_info" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#885-890">source</a><h4 class="code-header">pub fn <a href="#method.connect_to_display_with_auth_info" class="fn">connect_to_display_with_auth_info</a>(
    display_name: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.str.html">str</a>&gt;,
    auth_info: <a class="struct" href="struct.AuthInfo.html" title="struct xcb::AuthInfo">AuthInfo</a>&lt;'_&gt;,
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server, using an authorization information.</p>
<p>Connects to the X server specified by <code>display_name</code>, using the
authorization <code>auth_info</code>. If a particular screen on that server, it is
returned in the second tuple member, which is otherwise set to <code>0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.connect_to_display_with_auth_info_and_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#903-940">source</a><h4 class="code-header">pub fn <a href="#method.connect_to_display_with_auth_info_and_extensions" class="fn">connect_to_display_with_auth_info_and_extensions</a>(
    display_name: <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.str.html">str</a>&gt;,
    auth_info: <a class="struct" href="struct.AuthInfo.html" title="struct xcb::AuthInfo">AuthInfo</a>&lt;'_&gt;,
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;(<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>, <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.i32.html">i32</a>)&gt;</h4></section></summary><div class="docblock"><p>Connects to the X server, using an authorization information.</p>
<p>Extension data specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<p>Connects to the X server specified by <code>display_name</code>, using the
authorization <code>auth_info</code>. If a particular screen on that server, it is
returned in the second tuple member, which is otherwise set to <code>0</code>.</p>
<h5 id="panics-3"><a class="doc-anchor" href="#panics-3">§</a>Panics</h5>
<p>Panics if one of the mandatory extension is not present.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_raw_conn" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#946-948">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_conn" class="fn">from_raw_conn</a>(conn: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="enum" href="ffi/enum.xcb_connection_t.html" title="enum xcb::ffi::xcb_connection_t">xcb_connection_t</a>) -&gt; <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h4></section></summary><div class="docblock"><p>builds a new Connection object from an available connection</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>The <code>conn</code> pointer must point to a valid <code>xcb_connection_t</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_raw_conn_and_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#961-1009">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw_conn_and_extensions" class="fn">from_raw_conn_and_extensions</a>(
    conn: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="enum" href="ffi/enum.xcb_connection_t.html" title="enum xcb::ffi::xcb_connection_t">xcb_connection_t</a>,
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h4></section></summary><div class="docblock"><p>Builds a new <code>Connection</code> object from an available connection and cache the extension data</p>
<p>Extension data specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<h5 id="panics-4"><a class="doc-anchor" href="#panics-4">§</a>Panics</h5>
<p>Panics if the connection is null or in error state.
Panics if one of the mandatory extension is not present.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>The <code>conn</code> pointer must point to a valid <code>xcb_connection_t</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_xlib_display" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1021-1023">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_xlib_display" class="fn">from_xlib_display</a>(dpy: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="type" href="../x11/xlib/type.Display.html" title="type x11::xlib::Display">Display</a>) -&gt; <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h4></section></summary><div class="docblock"><p>Initialize a new <code>Connection</code> from an existing Xlib display.</p>
<p>Wraps a <code>xlib::Display</code> and get an XCB connection from an exisiting object
<code>xlib::XCloseDisplay</code> will be called when the returned object is dropped.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p>The <code>dpy</code> pointer must be a pointer to a valid <code>xlib::Display</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_xlib_display_and_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1041-1073">source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_xlib_display_and_extensions" class="fn">from_xlib_display_and_extensions</a>(
    dpy: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="type" href="../x11/xlib/type.Display.html" title="type x11::xlib::Display">Display</a>,
    mandatory: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
    optional: &amp;[<a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>],
) -&gt; <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h4></section></summary><div class="docblock"><p>Initialize a new <code>Connection</code> from an existing Xlib display.</p>
<p>Wraps a <code>xlib::Display</code> and get an XCB connection from an exisiting object
<code>xlib::XCloseDisplay</code> will be called when the returned object is dropped.</p>
<p>Extension data specified by <code>mandatory</code> and <code>optional</code> is cached to allow
the resolution of events and errors in these extensions.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
<h5 id="panics-5"><a class="doc-anchor" href="#panics-5">§</a>Panics</h5>
<p>Panics if the connection is null or in error state.</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>The <code>dpy</code> pointer must be a pointer to a valid <code>xlib::Display</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.active_extensions" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1091-1093">source</a><h4 class="code-header">pub fn <a href="#method.active_extensions" class="fn">active_extensions</a>(&amp;self) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>&gt; + '_</h4></section></summary><div class="docblock"><p>Get the extensions activated for this connection.</p>
<p>You may use this to check if an optional extension is present or not.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">// Xkb is mandatory, Input is optional
    </span><span class="kw">let </span>(conn, screen) = xcb::Connection::connect_with_extensions(
        <span class="prelude-val">None</span>, <span class="kw-2">&amp;</span>[xcb::Extension::Xkb], <span class="kw-2">&amp;</span>[xcb::Extension::Input]
    )<span class="question-mark">?</span>;
    <span class="comment">// now we check if Input is present or not
    </span><span class="kw">let </span>has_input_ext = conn.active_extensions().any(|e| e == xcb::Extension::Input);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.active_extensions_data" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1099-1101">source</a><h4 class="code-header">pub fn <a href="#method.active_extensions_data" class="fn">active_extensions_data</a>(&amp;self) -&gt; &amp;[<a class="struct" href="struct.ExtensionData.html" title="struct xcb::ExtensionData">ExtensionData</a>]</h4></section></summary><div class="docblock"><p>Get the data of the extensions activated for this connection.</p>
<p>You may use this to manually resolve an event or an error with
<code>xcb::event::resolve_event</code> or <code>xcb::error::resolve_error</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_raw_conn" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1104-1106">source</a><h4 class="code-header">pub fn <a href="#method.get_raw_conn" class="fn">get_raw_conn</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="enum" href="ffi/enum.xcb_connection_t.html" title="enum xcb::ffi::xcb_connection_t">xcb_connection_t</a></h4></section></summary><div class="docblock"><p>Returns the inner ffi <code>xcb_connection_t</code> pointer</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_raw_conn" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1109-1113">source</a><h4 class="code-header">pub fn <a href="#method.into_raw_conn" class="fn">into_raw_conn</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="enum" href="ffi/enum.xcb_connection_t.html" title="enum xcb::ffi::xcb_connection_t">xcb_connection_t</a></h4></section></summary><div class="docblock"><p>Consumes this object, returning the inner ffi <code>xcb_connection_t</code> pointer</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_raw_dpy" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1119-1121">source</a><h4 class="code-header">pub fn <a href="#method.get_raw_dpy" class="fn">get_raw_dpy</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="type" href="../x11/xlib/type.Display.html" title="type x11::xlib::Display">Display</a></h4></section></summary><div class="docblock"><p>Returns the inner ffi <code>xlib::Display</code> pointer.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_event_queue_owner" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1128-1139">source</a><h4 class="code-header">pub fn <a href="#method.set_event_queue_owner" class="fn">set_event_queue_owner</a>(&amp;self, owner: <a class="enum" href="enum.EventQueueOwner.html" title="enum xcb::EventQueueOwner">EventQueueOwner</a>)</h4></section></summary><div class="docblock"><p>Sets the owner of the event queue in the case if the connection is opened
with the Xlib interface. In that case, the default owner is Xlib.</p>
<p>This function is behind the <code>xlib_xcb</code> cargo feature.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_maximum_request_length" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1152-1154">source</a><h4 class="code-header">pub fn <a href="#method.get_maximum_request_length" class="fn">get_maximum_request_length</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns the maximum request length that this server accepts.</p>
<p>In the absence of the BIG-REQUESTS extension, returns the
maximum request length field from the connection setup data, which
may be as much as 65535. If the server supports BIG-REQUESTS, then
the maximum request length field from the reply to the
BigRequestsEnable request will be returned instead.</p>
<p>Note that this length is measured in four-byte units, making the
theoretical maximum lengths roughly 256kB without BIG-REQUESTS and
16GB with.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefetch_maximum_request_length" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1168-1172">source</a><h4 class="code-header">pub fn <a href="#method.prefetch_maximum_request_length" class="fn">prefetch_maximum_request_length</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Prefetch the maximum request length without blocking.</p>
<p>Without blocking, does as much work as possible toward computing
the maximum request length accepted by the X server.</p>
<p>Invoking this function may send the <a href="bigreq/struct.Enable.html" title="struct xcb::bigreq::Enable">crate::bigreq::Enable</a> request,
but will not block waiting for the reply.
<a href="struct.Connection.html#method.get_maximum_request_length" title="method xcb::Connection::get_maximum_request_length">Connection::get_maximum_request_length</a> will return the prefetched data
after possibly blocking while the reply is retrieved.</p>
<p>Note that in order for this function to be fully non-blocking, the
application must previously have called <a href="bigreq/fn.prefetch_extension_data.html" title="fn xcb::bigreq::prefetch_extension_data">crate::bigreq::prefetch_extension_data</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.generate_id" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1187-1189">source</a><h4 class="code-header">pub fn <a href="#method.generate_id" class="fn">generate_id</a>&lt;T: <a class="trait" href="trait.XidNew.html" title="trait xcb::XidNew">XidNew</a>&gt;(&amp;self) -&gt; T</h4></section></summary><div class="docblock"><p>Allocates an XID for a new object.</p>
<p>Returned value is typically used in requests such as <code>CreateWindow</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>window: x::Window = conn.generate_id();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.flush" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1204-1214">source</a><h4 class="code-header">pub fn <a href="#method.flush" class="fn">flush</a>(&amp;self) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Forces any buffered output to be written to the server.</p>
<p>Forces any buffered output to be written to the server. Blocks
until the write is complete.</p>
<p>There are several occasions ones want to flush the connection.
One of them is before entering or re-entering the event loop after performing unchecked requests.</p>
<p>The main difference between <code>flush</code> and <code>check_request</code> is that <code>flush</code> will not report protocol errors.
If a protocol error is emitted by an unchecked void request, it will be reported through the event loop.</p>
<p>See also: <a href="struct.Connection.html#method.wait_for_event" title="method xcb::Connection::wait_for_event">wait_for_event</a>, <a href="struct.Connection.html#method.check_request" title="method xcb::Connection::check_request">check_request</a>,
<a href="struct.Connection.html#method.send_and_check_request" title="method xcb::Connection::send_and_check_request">send_and_check_request</a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resolve_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1222-1224">source</a><h4 class="code-header">pub unsafe fn <a href="#method.resolve_event" class="fn">resolve_event</a>(&amp;self, ev: &amp;mut <a class="struct" href="ffi/struct.xcb_generic_event_t.html" title="struct xcb::ffi::xcb_generic_event_t">xcb_generic_event_t</a>) -&gt; <a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a></h4></section></summary><div class="docblock"><p>Resolve an xcb_generic_event_t pointer into an Event.</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h5>
<p>The caller is repsonsible to ensure that the <code>ev</code> pointer is not NULL.
The ownership of the pointer is effectively transferred to the
returned Event and it will be destroyed when the Event is
dropped.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resolve_error" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1232-1234">source</a><h4 class="code-header">pub unsafe fn <a href="#method.resolve_error" class="fn">resolve_error</a>(
    &amp;self,
    err: &amp;mut <a class="struct" href="ffi/struct.xcb_generic_error_t.html" title="struct xcb::ffi::xcb_generic_error_t">xcb_generic_error_t</a>,
) -&gt; <a class="enum" href="enum.ProtocolError.html" title="enum xcb::ProtocolError">ProtocolError</a></h4></section></summary><div class="docblock"><p>Resolve an xcb_generic_error_t pointer into an Error.</p>
<h5 id="safety-5"><a class="doc-anchor" href="#safety-5">§</a>Safety</h5>
<p>The caller is repsonsible to ensure that the <code>err</code> pointer is not NULL.
The ownership of the pointer is effectively transferred to the
returned Error and it will be destroyed when the Error is
dropped.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait_for_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1270-1275">source</a><h4 class="code-header">pub fn <a href="#method.wait_for_event" class="fn">wait_for_event</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;</h4></section></summary><div class="docblock"><p>Blocks and returns the next event or error from the server.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>xcb::x;
<span class="kw">fn </span>main() -&gt; xcb::Result&lt;()&gt; {
    <span class="comment">// ...
    </span><span class="kw">loop </span>{
        <span class="kw">let </span>event = <span class="kw">match </span>conn.wait_for_event() {
            <span class="prelude-val">Err</span>(xcb::Error::Connection(err)) =&gt; {
                <span class="macro">panic!</span>(<span class="string">"unexpected I/O error: {}"</span>, err);
            }
            <span class="prelude-val">Err</span>(xcb::Error::Protocol(xcb::ProtocolError::X(x::Error::Font(err), _req_name))) =&gt; {
                <span class="comment">// may be this particular error is fine?
                </span><span class="kw">continue</span>;
            }
            <span class="prelude-val">Err</span>(xcb::Error::Protocol(err)) =&gt; {
                <span class="macro">panic!</span>(<span class="string">"unexpected protocol error: {:#?}"</span>, err);
            }
            <span class="prelude-val">Ok</span>(event) =&gt; event,
        };
        <span class="kw">match </span>event {
            xcb::Event::X(x::Event::KeyPress(ev)) =&gt; {
                <span class="comment">// do stuff with the key press
            </span>}
            <span class="comment">// handle other events
            </span><span class="kw">_ </span>=&gt; {
                <span class="kw">break </span><span class="prelude-val">Ok</span>(());
            }
        }
    }
 }</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1284-1289">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_event" class="fn">poll_for_event</a>(&amp;self) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the next event or error from the server without blocking.</p>
<p>Returns the next event or error from the server, if one is
available. If no event is available, that
might be because an I/O error like connection close occurred while
attempting to read the next event, in which case the connection is
shut down when this function returns.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_queued_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1301-1312">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_queued_event" class="fn">poll_for_queued_event</a>(&amp;self) -&gt; <a class="type" href="type.ProtocolResult.html" title="type xcb::ProtocolResult">ProtocolResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the next event without reading from the connection.</p>
<p>This is a version of <a href="struct.Connection.html#method.poll_for_event" title="method xcb::Connection::poll_for_event">Connection::poll_for_event</a> that only examines the
event queue for new events. The function doesn’t try to read new
events from the connection if no queued events are found.</p>
<p>This function is useful for callers that know in advance that all
interesting events have already been read from the connection. For
example, callers might use <a href="struct.Connection.html#method.wait_for_reply" title="method xcb::Connection::wait_for_reply">Connection::wait_for_reply</a> and be interested
only of events that preceded a specific reply.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.register_for_special_xge" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1323-1339">source</a><h4 class="code-header">pub fn <a href="#method.register_for_special_xge" class="fn">register_for_special_xge</a>&lt;XGE: <a class="trait" href="trait.GeEvent.html" title="trait xcb::GeEvent">GeEvent</a>&gt;(&amp;self) -&gt; <a class="struct" href="struct.SpecialEventId.html" title="struct xcb::SpecialEventId">SpecialEventId</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: Broken API: use <code>register_for_special_event</code> instead</span></div></span></summary><div class="docblock"><p>Start listening for a special event.</p>
<p>Effectively creates an internal special queue for this event
XGE events are only defined in the <code>xinput</code> and <code>present</code> extensions</p>
<p>This function is present only if either of the <code>xinput</code> or <code>present</code> cargo features are active.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unregister_for_special_xge" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1345-1349">source</a><h4 class="code-header">pub fn <a href="#method.unregister_for_special_xge" class="fn">unregister_for_special_xge</a>(&amp;self, se: <a class="struct" href="struct.SpecialEventId.html" title="struct xcb::SpecialEventId">SpecialEventId</a>)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: use <code>unregister_for_special_event</code> instead</span></div></span></summary><div class="docblock"><p>Stop listening to a special event</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait_for_special_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1355-1360">source</a><h4 class="code-header">pub fn <a href="#method.wait_for_special_event" class="fn">wait_for_special_event</a>(&amp;self, se: <a class="struct" href="struct.SpecialEventId.html" title="struct xcb::SpecialEventId">SpecialEventId</a>) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: Broken API: use <code>wait_for_special_event2</code> instead</span></div></span></summary><div class="docblock"><p>Returns the next event from a special queue, blocking until one arrives</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_special_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1366-1371">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_special_event" class="fn">poll_for_special_event</a>(
    &amp;self,
    se: <a class="struct" href="struct.SpecialEventId.html" title="struct xcb::SpecialEventId">SpecialEventId</a>,
) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated: Broken API: use <code>poll_for_special_event2</code> instead</span></div></span></summary><div class="docblock"><p>Returns the next event from a special queue</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.register_for_special_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1380-1398">source</a><h4 class="code-header">pub fn <a href="#method.register_for_special_event" class="fn">register_for_special_event</a>&lt;EID: <a class="trait" href="trait.Xid.html" title="trait xcb::Xid">Xid</a>&gt;(
    &amp;self,
    extension: <a class="enum" href="enum.Extension.html" title="enum xcb::Extension">Extension</a>,
    eid: EID,
) -&gt; <a class="struct" href="struct.SpecialEvent.html" title="struct xcb::SpecialEvent">SpecialEvent</a></h4></section></summary><div class="docblock"><p>Start listening for a special event.</p>
<p>Effectively creates an internal special queue for this event
XGE events are only defined in the <code>xinput</code> and <code>present</code> extensions</p>
<p>This function is present only if either of the <code>xinput</code> or <code>present</code> cargo features are active.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unregister_for_special_event" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1402-1406">source</a><h4 class="code-header">pub fn <a href="#method.unregister_for_special_event" class="fn">unregister_for_special_event</a>(&amp;self, se: <a class="struct" href="struct.SpecialEvent.html" title="struct xcb::SpecialEvent">SpecialEvent</a>)</h4></section></summary><div class="docblock"><p>Stop listening to a special event</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait_for_special_event2" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1410-1415">source</a><h4 class="code-header">pub fn <a href="#method.wait_for_special_event2" class="fn">wait_for_special_event2</a>(&amp;self, se: &amp;<a class="struct" href="struct.SpecialEvent.html" title="struct xcb::SpecialEvent">SpecialEvent</a>) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the next event from a special queue, blocking until one arrives</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_special_event2" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1419-1424">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_special_event2" class="fn">poll_for_special_event2</a>(
    &amp;self,
    se: &amp;<a class="struct" href="struct.SpecialEvent.html" title="struct xcb::SpecialEvent">SpecialEvent</a>,
) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="enum.Event.html" title="enum xcb::Event">Event</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the next event from a special queue</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_setup" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1451-1458">source</a><h4 class="code-header">pub fn <a href="#method.get_setup" class="fn">get_setup</a>(&amp;self) -&gt; &amp;<a class="struct" href="x/struct.Setup.html" title="struct xcb::x::Setup">Setup</a></h4></section></summary><div class="docblock"><p>Access the data returned by the server.</p>
<p>Accessor for the data returned by the server when the connection
was initialized. This data includes</p>
<ul>
<li>the server’s required format for images,</li>
<li>a list of available visuals,</li>
<li>a list of available screens,</li>
<li>the server’s maximum request length (in the absence of the
BIG-REQUESTS extension),</li>
<li>and other assorted information.</li>
</ul>
<p>See the X protocol specification for more details.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_error" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1466-1468">source</a><h4 class="code-header">pub fn <a href="#method.has_error" class="fn">has_error</a>(&amp;self) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Test whether the connection has shut down due to a fatal error.</p>
<p>Some errors that occur in the context of a connection
are unrecoverable. When such an error occurs, the
connection is shut down and further operations on the
connection have no effect.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_request" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1515-1520">source</a><h4 class="code-header">pub fn <a href="#method.send_request" class="fn">send_request</a>&lt;R&gt;(&amp;self, req: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;R</a>) -&gt; R::<a class="associatedtype" href="trait.Request.html#associatedtype.Cookie" title="type xcb::Request::Cookie">Cookie</a><div class="where">where
    R: <a class="trait" href="trait.Request.html" title="trait xcb::Request">Request</a>,</div></h4></section></summary><div class="docblock"><p>Send a request to the X server.</p>
<p>This function never blocks. A cookie is returned to keep track of the request.
If the request expect a reply, the cookie can be used to retrieve the reply with
<a href="struct.Connection.html#method.wait_for_reply" title="method xcb::Connection::wait_for_reply">Connection::wait_for_reply</a>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="comment">// Example of void request.
    // Error (if any) will be sent to the event loop (see `wait_for_event`).
    // In this case, the cookie can be discarded.
    </span>conn.send_request(<span class="kw-2">&amp;</span>x::CreateWindow {
        depth: x::COPY_FROM_PARENT <span class="kw">as </span>u8,
        wid: window,
        parent: screen.root(),
        x: <span class="number">0</span>,
        y: <span class="number">0</span>,
        width: <span class="number">150</span>,
        height: <span class="number">150</span>,
        border_width: <span class="number">10</span>,
        class: x::WindowClass::InputOutput,
        visual: screen.root_visual(),
        value_list: <span class="kw-2">&amp;</span>[
            x::Cw::BackPixel(screen.white_pixel()),
            x::Cw::EventMask(x::EventMask::EXPOSURE | x::EventMask::KEY_PRESS),
        ],
    });

    <span class="comment">// Example of request with reply. The error (if any) is obtained with the reply.
    </span><span class="kw">let </span>cookie = conn.send_request(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    });
    <span class="kw">let </span>wm_protocols_atom: x::Atom = conn
            .wait_for_reply(cookie)<span class="question-mark">?
            </span>.atom();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_request_checked" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1538-1543">source</a><h4 class="code-header">pub fn <a href="#method.send_request_checked" class="fn">send_request_checked</a>&lt;R&gt;(&amp;self, req: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;R</a>) -&gt; <a class="struct" href="struct.VoidCookieChecked.html" title="struct xcb::VoidCookieChecked">VoidCookieChecked</a><div class="where">where
    R: <a class="trait" href="trait.RequestWithoutReply.html" title="trait xcb::RequestWithoutReply">RequestWithoutReply</a>,</div></h4></section></summary><div class="docblock"><p>Send a checked request to the X server.</p>
<p>Checked requests do not expect a reply, but the returned cookie can be used to check for
errors using <code>Connection::check_request</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span>cookie = conn.send_request_checked(<span class="kw-2">&amp;</span>x::MapWindow { window });
    conn.check_request(cookie)<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_request_unchecked" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1566-1571">source</a><h4 class="code-header">pub fn <a href="#method.send_request_unchecked" class="fn">send_request_unchecked</a>&lt;R&gt;(&amp;self, req: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;R</a>) -&gt; R::<a class="associatedtype" href="trait.RequestWithReply.html#associatedtype.CookieUnchecked" title="type xcb::RequestWithReply::CookieUnchecked">CookieUnchecked</a><div class="where">where
    R: <a class="trait" href="trait.RequestWithReply.html" title="trait xcb::RequestWithReply">RequestWithReply</a>,</div></h4></section></summary><div class="docblock"><p>Send an unchecked request to the X server.</p>
<p>Unchecked requests expect a reply that is to be retrieved by <a href="struct.Connection.html#method.wait_for_reply_unchecked" title="method xcb::Connection::wait_for_reply_unchecked">Connection::wait_for_reply_unchecked</a>.
Unchecked means that the error is not checked when the reply is fetched. Instead, the error will
be sent to the event loop</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span>cookie = conn.send_request_unchecked(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    });
    <span class="kw">let </span>wm_protocols_atom: <span class="prelude-ty">Option</span>&lt;x::Atom&gt; = conn
            .wait_for_reply_unchecked(cookie)<span class="question-mark">?
            </span>.map(|rep| rep.atom());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.check_request" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1595-1608">source</a><h4 class="code-header">pub fn <a href="#method.check_request" class="fn">check_request</a>(&amp;self, cookie: <a class="struct" href="struct.VoidCookieChecked.html" title="struct xcb::VoidCookieChecked">VoidCookieChecked</a>) -&gt; <a class="type" href="type.ProtocolResult.html" title="type xcb::ProtocolResult">ProtocolResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>&gt;</h4></section></summary><div class="docblock"><p>Check a checked request for errors.</p>
<p>The cookie supplied to this function must have resulted
from a call to <a href="struct.Connection.html#method.send_request_checked" title="method xcb::Connection::send_request_checked">Connection::send_request_checked</a>.  This function will block
until one of two conditions happens.  If an error is received, it will be
returned.  If a reply to a subsequent request has already arrived, no error
can arrive for this request, so this function will return <code>Ok(())</code>.</p>
<p>Note that this function will perform a sync if needed to ensure that the
sequence number will advance beyond that provided in cookie; this is a
convenience to avoid races in determining whether the sync is needed.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    conn.check_request(conn.send_request_checked(<span class="kw-2">&amp;</span>x::MapWindow { window }))<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.send_and_check_request" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1629-1634">source</a><h4 class="code-header">pub fn <a href="#method.send_and_check_request" class="fn">send_and_check_request</a>&lt;R&gt;(&amp;self, req: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;R</a>) -&gt; <a class="type" href="type.ProtocolResult.html" title="type xcb::ProtocolResult">ProtocolResult</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.unit.html">()</a>&gt;<div class="where">where
    R: <a class="trait" href="trait.RequestWithoutReply.html" title="trait xcb::RequestWithoutReply">RequestWithoutReply</a>,</div></h4></section></summary><div class="docblock"><p>Send the request to the server and check it.</p>
<p>This is a sugar for <code>conn.check_request(conn.send_request_checked(req))</code></p>
<p>This method is useful as well in place of code sending a void request
and flushing the connection right after. Checking the request effectively
flushes the connection, but in addition reports possible protocol errors
at the calling site instead of reporting them through the event loop.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    conn.send_and_check_request(<span class="kw-2">&amp;</span>x::MapWindow { window })<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait_for_reply" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1658-1667">source</a><h4 class="code-header">pub fn <a href="#method.wait_for_reply" class="fn">wait_for_reply</a>&lt;C&gt;(&amp;self, cookie: C) -&gt; <a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;C::<a class="associatedtype" href="trait.CookieWithReplyChecked.html#associatedtype.Reply" title="type xcb::CookieWithReplyChecked::Reply">Reply</a>&gt;<div class="where">where
    C: <a class="trait" href="trait.CookieWithReplyChecked.html" title="trait xcb::CookieWithReplyChecked">CookieWithReplyChecked</a>,</div></h4></section></summary><div class="docblock"><p>Gets the reply of a previous request, or an error if one occurred.</p>
<p>This is blocking; it does not return until the reply has been received. For the non-blocking
version, see <a href="struct.Connection.html#method.poll_for_reply" title="method xcb::Connection::poll_for_reply"><code>poll_for_reply</code></a>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span>cookie = conn.send_request(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    });
    <span class="kw">let </span>wm_protocols_atom: x::Atom = conn
            .wait_for_reply(cookie)<span class="question-mark">?
            </span>.atom();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wait_for_reply_unchecked" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1693-1701">source</a><h4 class="code-header">pub fn <a href="#method.wait_for_reply_unchecked" class="fn">wait_for_reply_unchecked</a>&lt;C&gt;(
    &amp;self,
    cookie: C,
) -&gt; <a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;C::<a class="associatedtype" href="trait.CookieWithReplyUnchecked.html#associatedtype.Reply" title="type xcb::CookieWithReplyUnchecked::Reply">Reply</a>&gt;&gt;<div class="where">where
    C: <a class="trait" href="trait.CookieWithReplyUnchecked.html" title="trait xcb::CookieWithReplyUnchecked">CookieWithReplyUnchecked</a>,</div></h4></section></summary><div class="docblock"><p>Get the reply of a previous unchecked request.</p>
<p>If an error occurred, <code>None</code> is returned and the error will be delivered to the event loop.</p>
<p>This is blocking; it does not return until the reply has been received. For the non-blocking
version, see <a href="struct.Connection.html#method.poll_for_reply_unchecked" title="method xcb::Connection::poll_for_reply_unchecked"><code>poll_for_reply_unchecked</code></a>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>    <span class="kw">let </span>cookie = conn.send_request_unchecked(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    });
    <span class="kw">let </span>wm_protocols_atom: <span class="prelude-ty">Option</span>&lt;x::Atom&gt; = conn
            .wait_for_reply_unchecked(cookie)<span class="question-mark">?  </span><span class="comment">// connection error may happen
            </span>.map(|rep| rep.atom());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_reply" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1760-1781">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_reply" class="fn">poll_for_reply</a>&lt;C&gt;(&amp;self, cookie: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;C</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.Result.html" title="type xcb::Result">Result</a>&lt;C::<a class="associatedtype" href="trait.CookieWithReplyChecked.html#associatedtype.Reply" title="type xcb::CookieWithReplyChecked::Reply">Reply</a>&gt;&gt;<div class="where">where
    C: <a class="trait" href="trait.CookieWithReplyChecked.html" title="trait xcb::CookieWithReplyChecked">CookieWithReplyChecked</a>,</div></h4></section></summary><div class="docblock"><p>Gets the reply of a previous request if it has been received, or an error if one occurred.</p>
<p>This is non-blocking; if no reply has been received yet, it returns <a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a>. For the
blocking version, see <a href="struct.Connection.html#method.wait_for_reply" title="method xcb::Connection::wait_for_reply"><code>wait_for_reply</code></a>.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(wm_protocols_cookie, wm_name_cookie) = (
    conn.send_request(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    }),
    conn.send_request(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_NAME"</span>,
    }),
);
<span class="kw">let </span>(wm_protocols_atom, wm_name_atom) = {
    <span class="kw">let </span>(
        <span class="kw-2">mut </span>wm_protocols_atom,
        <span class="kw-2">mut </span>wm_name_atom,
    ) = (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>);

    <span class="kw">loop </span>{
        <span class="comment">// If `wm_protocols_atom` is yet to be received, poll for it.
        </span><span class="kw">if </span>wm_protocols_atom.is_none() {
            wm_protocols_atom = conn
                .poll_for_reply(<span class="kw-2">&amp;</span>wm_protocols_cookie)
                .transpose()<span class="question-mark">?
                </span>.map(|reply| reply.atom());
        }
        <span class="comment">// If `wm_name_atom` is yet to be received, poll for it.
        </span><span class="kw">if </span>wm_name_atom.is_none() {
            wm_name_atom = conn
                .poll_for_reply(<span class="kw-2">&amp;</span>wm_name_cookie)
                .transpose()<span class="question-mark">?
                </span>.map(|reply| reply.atom());
        }

        <span class="comment">// If both `wm_protocols_atom` and `wm_name_atom` have been
        // received, break from the loop.
        </span><span class="kw">if let </span>(
            <span class="prelude-val">Some</span>(wm_protocols_atom),
            <span class="prelude-val">Some</span>(wm_name_atom),
        ) = (wm_protocols_atom, wm_name_atom) {
            <span class="kw">break </span>(wm_protocols_atom, wm_name_atom);
        }
    }
};</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.poll_for_reply_unchecked" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1851-1871">source</a><h4 class="code-header">pub fn <a href="#method.poll_for_reply_unchecked" class="fn">poll_for_reply_unchecked</a>&lt;C&gt;(
    &amp;self,
    cookie: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;C</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.ConnResult.html" title="type xcb::ConnResult">ConnResult</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;C::<a class="associatedtype" href="trait.CookieWithReplyUnchecked.html#associatedtype.Reply" title="type xcb::CookieWithReplyUnchecked::Reply">Reply</a>&gt;&gt;&gt;<div class="where">where
    C: <a class="trait" href="trait.CookieWithReplyUnchecked.html" title="trait xcb::CookieWithReplyUnchecked">CookieWithReplyUnchecked</a>,</div></h4></section></summary><div class="docblock"><p>Gets the reply of a previous unchecked request if it has been received.</p>
<p>If an error occurred, <a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> is returned and the error is delivered to the event loop.</p>
<p>This is non-blocking; if no reply has been received yet, it returns
<code><a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.Some" title="variant core::option::Option::Some">Some</a>(<a href="https://doc.rust-lang.org/1.83.0/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None">None</a>)</code>. For the blocking version, see <a href="struct.Connection.html#method.wait_for_reply_unchecked" title="method xcb::Connection::wait_for_reply_unchecked"><code>wait_for_reply_unchecked</code></a>.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(wm_protocols_cookie, wm_name_cookie) = (
    conn.send_request_unchecked(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_PROTOCOLS"</span>,
    }),
    conn.send_request_unchecked(<span class="kw-2">&amp;</span>x::InternAtom {
        only_if_exists: <span class="bool-val">true</span>,
        name: <span class="string">b"WM_NAME"</span>,
    }),
);
<span class="kw">let </span>(wm_protocols_atom, wm_name_atom) = {
    <span class="kw">let </span>(
        <span class="kw-2">mut </span>wm_protocols_atom,
        <span class="kw-2">mut </span>wm_name_atom,
    ) = (<span class="prelude-val">Some</span>(<span class="prelude-val">None</span>), <span class="prelude-val">Some</span>(<span class="prelude-val">None</span>));

    <span class="kw">loop </span>{
        <span class="comment">// If `wm_protocols_atom` is yet to be received, poll for it.
        </span><span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="prelude-val">None</span>) = wm_protocols_atom {
            wm_protocols_atom = conn
                <span class="comment">// connection error may happen
                </span>.poll_for_reply_unchecked(<span class="kw-2">&amp;</span>wm_protocols_cookie)
                .transpose()<span class="question-mark">?
                </span>.map(|result| result.map(|reply| reply.atom()));
        }
        <span class="comment">// If `wm_name_atom` is yet to be received, poll for it.
        </span><span class="kw">if let </span><span class="prelude-val">Some</span>(<span class="prelude-val">None</span>) = wm_name_atom {
            wm_name_atom = conn
                <span class="comment">// connection error may happen
                </span>.poll_for_reply_unchecked(<span class="kw-2">&amp;</span>wm_name_cookie)
                .transpose()<span class="question-mark">?
                </span>.map(|result| result.map(|reply| reply.atom()));
        }

        <span class="kw">match </span>(wm_protocols_atom, wm_name_atom) {
            <span class="comment">// If either `wm_protocols_atom` or `wm_name_atom` hasn't
            // been received, continue the loop.
            </span>(<span class="prelude-val">Some</span>(<span class="prelude-val">None</span>), <span class="kw">_</span>) | (<span class="kw">_</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">None</span>)) =&gt; <span class="kw">continue</span>,

            <span class="comment">// Otherwise, if both have been received, break from the
            // loop.
            </span>(
                wm_protocols_atom,
                wm_name_atom,
            ) =&gt; <span class="kw">break </span>(
                wm_protocols_atom.flatten(),
                wm_name_atom.flatten(),
            ),
        }
    }
};</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.total_read" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1882-1884">source</a><h4 class="code-header">pub fn <a href="#method.total_read" class="fn">total_read</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Obtain number of bytes read from the connection.</p>
<p>Returns cumulative number of bytes received from the connection.</p>
<p>This retrieves the total number of bytes read from this connection,
to be used for diagnostic/monitoring/informative purposes.</p>
<p>Since: libxcb 1.14</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.total_written" class="method"><a class="src rightside" href="../src/xcb/base.rs.html#1895-1897">source</a><h4 class="code-header">pub fn <a href="#method.total_written" class="fn">total_written</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Obtain number of bytes written to the connection.</p>
<p>Returns cumulative number of bytes sent to the connection.</p>
<p>This retrieves the total number of bytes written to this connection,
to be used for diagnostic/monitoring/informative purposes.</p>
<p>Since: libxcb 1.14</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsRawFd-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#1964-1968">source</a><a href="#impl-AsRawFd-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/trait.AsRawFd.html" title="trait std::os::fd::raw::AsRawFd">AsRawFd</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_raw_fd" class="method trait-impl"><a class="src rightside" href="../src/xcb/base.rs.html#1965-1967">source</a><a href="#method.as_raw_fd" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/trait.AsRawFd.html#tymethod.as_raw_fd" class="fn">as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/type.RawFd.html" title="type std::os::fd::raw::RawFd">RawFd</a></h4></section></summary><div class='docblock'>Extracts the raw file descriptor. <a href="https://doc.rust-lang.org/1.83.0/std/os/fd/raw/trait.AsRawFd.html#tymethod.as_raw_fd">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRawXcbConnection-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#1972-1976">source</a><a href="#impl-AsRawXcbConnection-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../as_raw_xcb_connection/trait.AsRawXcbConnection.html" title="trait as_raw_xcb_connection::AsRawXcbConnection">AsRawXcbConnection</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_raw_xcb_connection" class="method trait-impl"><a class="src rightside" href="../src/xcb/base.rs.html#1973-1975">source</a><a href="#method.as_raw_xcb_connection" class="anchor">§</a><h4 class="code-header">fn <a href="../as_raw_xcb_connection/trait.AsRawXcbConnection.html#tymethod.as_raw_xcb_connection" class="fn">as_raw_xcb_connection</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.pointer.html">*mut </a><a class="enum" href="../as_raw_xcb_connection/enum.xcb_connection_t.html" title="enum as_raw_xcb_connection::xcb_connection_t">xcb_connection_t</a></h4></section></summary><div class='docblock'>Get a raw xcb connection pointer from this object.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3CConnection%3E-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#1958-1962">source</a><a href="#impl-AsRef%3CConnection%3E-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a>&gt; for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="../src/xcb/base.rs.html#1959-1961">source</a><a href="#method.as_ref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Drop-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#1978-2001">source</a><a href="#impl-Drop-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../src/xcb/base.rs.html#1979-2000">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fn">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.83.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></div></details></div></details><section id="impl-Send-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#700">source</a><a href="#impl-Send-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section><section id="impl-Sync-for-Connection" class="impl"><a class="src rightside" href="../src/xcb/base.rs.html#701">source</a><a href="#impl-Sync-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Connection" class="impl"><a href="#impl-Freeze-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section><section id="impl-RefUnwindSafe-for-Connection" class="impl"><a href="#impl-RefUnwindSafe-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section><section id="impl-Unpin-for-Connection" class="impl"><a href="#impl-Unpin-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section><section id="impl-UnwindSafe-for-Connection" class="impl"><a href="#impl-UnwindSafe-for-Connection" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Connection.html" title="struct xcb::Connection">Connection</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/any.rs.html#138">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/any.rs.html#139">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.83.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.83.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#209">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#211">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#217">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.83.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/borrow.rs.html#218">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.83.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#809">source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#794">source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.83.0/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.83.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.83.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>